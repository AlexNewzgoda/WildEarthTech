#pragma kernel Deform
#pragma kernel ReduceUpdate
#pragma kernel DeformRectangle
#pragma kernel GetHeightValue
#pragma kernel BrushDeform
#pragma kernel BrushDeformSimple

RWStructuredBuffer<float> ResultBuffer;

Texture2D<float4> BrushTex;
float BrushScale;
uint BrushHalfSize;
bool BrushMirrorY;
float Angle;

Texture2D<float4> ReferenceTex;
RWTexture2D<float4> Result;
Texture2D<float4> ResultTarget;

float4 Pos;
float4 Pos1;
float4 Pos2;
float4 Pos3;
float4 Pos4;

float4 DeformOffset;

float DeformRadius;
float DeformPower;
float DeformDepth;

float Reduce;

float _deformSumm = 0;

[numthreads(8,8,1)]
void Deform (uint3 id : SV_DispatchThreadID)
{
    uint3 idS = id + DeformOffset;

    uint pixDist = distance(idS.xy, Pos.xy);
    uint drawRange = DeformRadius;
    float deltaD = (float)pixDist / drawRange;

    if (pixDist < drawRange - 10)
    {
        float offsetD = 1 - cos(deltaD);

        if(DeformPower > 1)
            offsetD = pow(offsetD, DeformPower);

        float rValue = offsetD + 1 - DeformDepth;

        float4 origValue = ReferenceTex[idS.xy];

        if(origValue.r > rValue)
        {
            Result[idS.xy] = float4(rValue, origValue.g, 0.0, 1.0);
        }
    }
    else if (pixDist < drawRange)
    {
        float4 origValue = ReferenceTex[idS.xy];

        float offsetD = 1 - cos(deltaD);

        if(DeformPower > 1)
            offsetD = pow(offsetD, DeformPower);

        float gValue = DeformDepth;

        gValue = gValue - (1 - origValue.r);

        if(origValue.g < gValue)
        {
            Result[idS.xy] = float4(origValue.r, gValue, 0.0, origValue.a);
        }
    }
}

//Reduce
[numthreads(8,8,1)]
void ReduceUpdate (uint3 id : SV_DispatchThreadID)
{
    float4 targetValue = ResultTarget[id.xy];
    float4 currentValue = ReferenceTex[id.xy];

    if(currentValue.r < targetValue.r)
        currentValue.r += Reduce;

    if(currentValue.r > targetValue.r)
        currentValue = targetValue;

    Result[id.xy] = currentValue; 
}

//Apply Rectangle
float2 vect2d(float2 p1, float2 p2)
{
        float2 temp;
        temp.x = (p2.x - p1.x);
        temp.y = -1 * (p2.y - p1.y);
        return temp;
}

bool pointInRectangle(float2 A, float2 B, float2 C, float2 D, float2 m)
{
        float2 AB = vect2d(A, B); float C1 = -1 * (AB.y * A.x + AB.x * A.y); float D1 = (AB.y * m.x + AB.x * m.y) + C1;
        float2 AD = vect2d(A, D); float C2 = -1 * (AD.y * A.x + AD.x * A.y); float D2 = (AD.y * m.x + AD.x * m.y) + C2;
        float2 BC = vect2d(B, C); float C3 = -1 * (BC.y * B.x + BC.x * B.y); float D3 = (BC.y * m.x + BC.x * m.y) + C3;
        float2 CD = vect2d(C, D); float C4 = -1 * (CD.y * C.x + CD.x * C.y); float D4 = (CD.y * m.x + CD.x * m.y) + C4;
        return 0 >= D1 && 0 >= D4 && 0 <= D2 && 0 >= D3;
}

[numthreads(8,8,1)]
void DeformRectangle (uint3 id : SV_DispatchThreadID)
{
    if(pointInRectangle(Pos1.xy, Pos2.xy, Pos3.xy, Pos4.xy, id.xy))
    {   
        float val = Result[id.xy].r;

        float2 c = Pos1.xy + ((Pos3.xy - Pos1.xy) * 0.5);

        uint dist = distance(c.xy, id.xy);
        float power = (float)dist / 64;
        power = pow(power, 10);

        Result[id.xy] = float4(min(val, power), 0.0, 0.0, 1.0);
    }
}

//Get Height
[numthreads(8,8,1)]
void GetHeightValue (uint3 id : SV_DispatchThreadID)
{
    uint3 idS = id + DeformOffset;

    uint pixDist = distance(idS.xy, Pos.xy);

    if(pixDist < DeformRadius)
    {
        ResultBuffer[0] += Result[idS.xy].r;
        ResultBuffer[1] += 1;
    }
}


[numthreads(8, 8, 1)]
void BrushDeform (uint3 id : SV_DispatchThreadID)
{
    float2x2 rotMatrix = float2x2(cos(Angle), -sin(Angle),
                              sin(Angle), cos(Angle));

    float2 brushCoord = id.xy;

    float2 pivot = float2(BrushHalfSize, BrushHalfSize) * BrushScale;

    brushCoord -= pivot;

    brushCoord = mul(rotMatrix, brushCoord);

    brushCoord += pivot;

    brushCoord /= BrushScale;

    float4 brushValue = BrushTex[brushCoord];

    if(brushValue.a > 0)
    {
        uint2 pos = id.xy - float2(BrushHalfSize, BrushHalfSize) * BrushScale + Pos.xy;

        float newValueR = 1 - (brushValue.r * brushValue.a);

        if(ReferenceTex[pos].r > newValueR)
        {
            Result[pos] = float4(newValueR, ReferenceTex[pos].gba);
        }       
    }
}

[numthreads(8, 8, 1)]
void BrushDeformSimple (uint3 id : SV_DispatchThreadID)
{
    uint2 brushCoord = id.xy / BrushScale;

    if(BrushMirrorY)
        brushCoord = uint2(BrushHalfSize * 2 - brushCoord.x, brushCoord.y);

    float4 brushValue = BrushTex[brushCoord];

    if(brushValue.a > 0)
    {
        uint2 pos = id.xy - float2(BrushHalfSize, BrushHalfSize) * BrushScale + Pos.xy;

        float newValueR = 1 - brushValue.r;

        if(ReferenceTex[pos].r > newValueR)
        {
            Result[pos] = float4(newValueR, 0.0, 0.0, 1.0);
        }
    }
}
